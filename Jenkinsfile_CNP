#!groovy
@Library("Infrastructure") _

import uk.gov.hmcts.contino.Environment
import uk.gov.hmcts.contino.HealthChecker
import uk.gov.hmcts.contino.azure.KeyVault

properties([
        parameters([
                string(name: "PRODUCT_NAME", defaultValue: "ccd-elastic-search", description: ""),
                booleanParam(name: "DEPLOY_ES_CLUSTER", defaultValue: false, description: "Select to deploy ElasticSearch"),
                booleanParam(name: "RUN_ANSIBLE_DRY", defaultValue: false, description: "Run Ansible in DRY run mode"),
                booleanParam(name: "RUN_ANSIBLE_APPLY", defaultValue: false, description: "Run Ansible in APPLY mode"),
                booleanParam(name: "UPGRADE_ES", defaultValue: true, description: "Whether to run ES version upgrade steps (deb packages re-deploy)"),
                booleanParam(name: "ROLLING_UPGRADE", defaultValue: false, description: "Run Ansible with rolling upgrade steps (demo/ithc only)"),
                booleanParam(name: "REINDEX", defaultValue: false, description: "Whether to re-index after version upgrade (demo/ithc only)"),
                string(name: "ANSIBLE_TARGETS", defaultValue: "demo,ithc", description: "Comma-separated environments for Ansible runs")
        ])
])

def setupSecret(String targetEnv) {
    def bootstrapEnv = targetEnv
    azureKeyVault(
        keyVaultURL: "https://ccd-${bootstrapEnv}.vault.azure.net/",
        secrets: [
            secret("ccd-vm-admin-name", "CCD_VM_ADMIN_NAME"),
            secret("ccd-ELASTIC-SEARCH-PRIVATE-KEY", "CCD_VM_SSH_PRIVATE_KEY")
        ]) {
            env.CCD_VM_ADMIN_NAME = "${CCD_VM_ADMIN_NAME}"
            env.CCD_VM_SSH_PRIVATE_KEY = "${CCD_VM_SSH_PRIVATE_KEY}"
        }
}

def supportsUpgradeFlags(String targetEnv) {
    ["demo", "ithc"].contains(targetEnv)
}

def runAnsible(String targetEnv) {
    setupSecret(targetEnv)

    echo "ANSIBLE Dry run: ${params.RUN_ANSIBLE_DRY}"
    echo "ANSIBLE Apply run: ${params.RUN_ANSIBLE_APPLY}"
    echo "Rolling upgrade (demo/ithc only): ${params.ROLLING_UPGRADE}"
    echo "Upgrade ES (demo/ithc only): ${params.UPGRADE_ES}"
    echo "Reindex (demo/ithc only): ${params.REINDEX}"

    def checkRunAnsible = params.RUN_ANSIBLE_APPLY ? "" : "--check"
    def buildTag = (env.BUILD_TAG ?: "local").replaceAll("[^A-Za-z0-9_.-]", "-")
    def venvPath = "/tmp/ansible-venv-${buildTag}"
    def keyPath = "/tmp/ccdadmin_key_${buildTag}"

    def upgradeEnabled = supportsUpgradeFlags(targetEnv)
    def rollingUpgrade = (upgradeEnabled && params.ROLLING_UPGRADE) ? "true" : "false"
    def reindex = (upgradeEnabled && params.REINDEX) ? "true" : "false"
    def upgradeEs = (upgradeEnabled && params.UPGRADE_ES) ? "true" : "false"
    def clusterName = "ccd-elastic-search-${targetEnv.replace("_", "-")}"

    try {
        writeFile file: keyPath, text: env.CCD_VM_SSH_PRIVATE_KEY
        sh "chmod 600 ${keyPath}"

        sh """
            python3 -m venv ${venvPath}
            ${venvPath}/bin/pip install --upgrade pip
            ${venvPath}/bin/pip install ansible==13.0.0
            ${venvPath}/bin/ansible --version
        """

        sh """
            ANSIBLE_HOST_KEY_CHECKING=False ${venvPath}/bin/ansible-playbook \
              -i ${WORKSPACE}/ansible/inventory.ini \
              ansible/diskmount.yml \
              -u ${CCD_VM_ADMIN_NAME} \
              --private-key=${keyPath} \
              --limit ${targetEnv} \
              ${checkRunAnsible}

            ANSIBLE_HOST_KEY_CHECKING=False ${venvPath}/bin/ansible-playbook \
              -i ${WORKSPACE}/ansible/inventory.ini \
              ansible/main.yml \
              -u ${CCD_VM_ADMIN_NAME} \
              --private-key=${keyPath} \
              --limit ${targetEnv} \
              --extra-vars 'elastic_clustername=${clusterName} rolling_upgrade=${rollingUpgrade} reindex=${reindex} upgrade_es=${upgradeEs}' \
              ${checkRunAnsible}
        """
    } finally {
        sh "rm -rf ${venvPath} ${keyPath}"
    }
}

def parseTargets() {
    params.ANSIBLE_TARGETS
        .split(",")
        .collect { it.trim() }
        .findAll { it }
        .toSet()
}

static Map<String, Object> secret(String secretName, String envVariable) {
    [
        $class: "AzureKeyVaultSecret",
        secretType: "Secret",
        name: secretName,
        envVariable: envVariable
    ]
}

withInfraPipeline(params.PRODUCT_NAME, null, !params.DEPLOY_ES_CLUSTER) {
    onMaster {
        enableSlackNotifications("#ccd-master-builds")
    }
    onDemo {
        enableSlackNotifications("#ccd-demo-builds")
    }

    afterAlways("buildinfra:aat") {
        echo "Healthcheck in AAT"
        healthCheckStage("nonprod", "aat")
    }
    afterAlways("buildinfra:prod") {
        echo "Healthcheck in PROD"
        healthCheckStage("prod", "prod")
    }
    afterAlways("buildinfra:perftest") {
        echo "Healthcheck in Perftest"
        healthCheckStage("qa", "perftest")
    }
    afterAlways("buildinfra:demo") {
        echo "Healthcheck in Demo"
        healthCheckStage("nonprod", "demo")
    }
    afterAlways("buildinfra:ithc") {
        echo "Healthcheck in ITHC"
        healthCheckStage("qa", "ithc")
    }

    if (params.RUN_ANSIBLE_DRY || params.RUN_ANSIBLE_APPLY) {
        def targets = parseTargets()

        afterSuccess("buildinfra:demo") {
            if (targets.contains("demo")) {
                echo "Running Ansible in demo"
                runAnsible("demo")
            } else {
                echo "Skipping demo Ansible: demo not in ANSIBLE_TARGETS=${params.ANSIBLE_TARGETS}"
            }
        }

        afterSuccess("buildinfra:ithc") {
            if (targets.contains("ithc")) {
                echo "Running Ansible in ithc"
                runAnsible("ithc")
            } else {
                echo "Skipping ithc Ansible: ithc not in ANSIBLE_TARGETS=${params.ANSIBLE_TARGETS}"
            }
        }
    }
}

def healthCheckStage(String subscription, String environmentName) {
    stage("HealthCheck") {
        def healthChecker = new HealthChecker(this)
        healthChecker.check(healthCheckUrl(subscription, environmentName), 10, 40) { response ->
            if (response.content.contains("yellow")) {
                currentBuild.result = "UNSTABLE"
            }
            !response.content.contains("red")
        }
    }
}

def healthCheckUrl(String subscription, String environmentName) {
    KeyVault keyVault = new KeyVault(this, subscription, "ccd-${environmentName}")
    def esUrl = keyVault.find("ccd-ELASTIC-SEARCH-URL").trim()
    echo "retrieved ES URL: ${esUrl}"
    "http://${esUrl}:9200/_cluster/health"
}
